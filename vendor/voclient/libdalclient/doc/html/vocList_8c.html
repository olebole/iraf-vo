<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DAL Client Library: vocList.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>vocList.c File Reference</h1><code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &quot;<a class="el" href="vocList_8h_source.html">vocList.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vocList_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vocList_8c.html#f24b90be778084df7a1918c0b8b33d45">vll_init</a> (long req_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new linked ist.  <a href="#f24b90be778084df7a1918c0b8b33d45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vocList_8c.html#ab00ac30bf145825e84a22bb55754ad3">vll_count</a> (vocList_t *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current size of the list.  <a href="#ab00ac30bf145825e84a22bb55754ad3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vocList_8c.html#a9876d2307012b54e4b534e74e7593b9">vll_seek</a> (vocList_t *list, long offset, int whence)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seek to the indicated position in the list.  <a href="#a9876d2307012b54e4b534e74e7593b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8d4716dba65c138edf75043ec2a1a4ac"></a><!-- doxytag: member="vocList.c::vll_find" ref="8d4716dba65c138edf75043ec2a1a4ac" args="(vocList_t *list, void *obj, long *index)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>vll_find</b> (vocList_t *list, void *obj, long *index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vocList_8c.html#94da8f1a5cf17ebf3c3e13aab340ddb6">vll_prev</a> (vocList_t *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the previous element in the list.  <a href="#94da8f1a5cf17ebf3c3e13aab340ddb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vocList_8c.html#26a1a38a174db6cd9d5903dad23cfcb8">vll_next</a> (vocList_t *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the next element in the list.  <a href="#26a1a38a174db6cd9d5903dad23cfcb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5f2095b6734c6dc699c64d2a4f04ad98"></a><!-- doxytag: member="vocList.c::vll_insert" ref="5f2095b6734c6dc699c64d2a4f04ad98" args="(vocList_t *list, void *obj, long *index)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>vll_insert</b> (vocList_t *list, void *obj, long *index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d614219da9ba8d6a7d8742dc226ce2ae"></a><!-- doxytag: member="vocList.c::vll_append" ref="d614219da9ba8d6a7d8742dc226ce2ae" args="(vocList_t *list, void *obj, long *index)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>vll_append</b> (vocList_t *list, void *obj, long *index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vocList_8c.html#72b0563b0c8c56ed8677410860b41b47">vll_remove</a> (vocList_t *list, long req_pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a node from the list.  <a href="#72b0563b0c8c56ed8677410860b41b47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vocList_8c.html#b10af1f0b19cb9493368bffe4a1f735b">vll_destroy</a> (vocList_t *list, void(*func)(void *ptr))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the List object and free resources.  <a href="#b10af1f0b19cb9493368bffe4a1f735b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vocList_8c.html#28e9778710835857c95b41cd83db5213">vll_rebuild_index</a> (vocList_t *list, int req_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rebuild the array index.  <a href="#28e9778710835857c95b41cd83db5213"></a><br></td></tr>
</table>
<hr><h2>Detailed Description</h2>
VOCLIST.C - Simple C Array-List Class.<p>
Lists are doubly-linked, with the value being a pointer to an arbitrary external object. The life cycle of the external object is not managed by the list. An unusual feature is that an array index is supported to permit randomly accessing the list as an array.<p>
list = vll_init (size) # create with initial size len = vll_count (list) # get current list length obj = vll_seek (list, offset, whence) # seek to offset from whence obj = vll_find (list, obj, index) # find next node with object obj = vll_prev (list) # back up one node obj = vll_next (list) # advance to next node obj = vll_insert (list, obj, index) # insert at current pos obj = vll_append (list, obj, index) # append to the list obj = vll_remove (list, pos) # remove node from list vll_destroy (list, func) # free all list resources<p>
The list may be traversed in either direction or may be randomly accessed like an array. The access methods (e.g., seek, prev, next) return a pointer to the object associated with the current list node.<p>
Note: This code is optimized for fairly static lists to which items are mainly appended. The need to maintain an index into the list requires that the index be rebuilt if elements are inserted or removed anywhere other than at the end of the list. Note that rebuilding the index can cause index values for nodes to change. Appending to the list has no performance penalty. These considerations affect only efficiency; inserting and removing elements at random is otherwise not affected.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Doug Tody </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>January 2014 </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ab00ac30bf145825e84a22bb55754ad3"></a><!-- doxytag: member="vocList.c::vll_count" ref="ab00ac30bf145825e84a22bb55754ad3" args="(vocList_t *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long vll_count           </td>
          <td>(</td>
          <td class="paramtype">vocList_t *&nbsp;</td>
          <td class="paramname"> <em>list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current size of the list. 
<p>
vll_count -- Return a count of the current number of list elements.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>Linked list to be accessed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of items currently in the List </dd></dl>

</div>
</div><p>
<a class="anchor" name="b10af1f0b19cb9493368bffe4a1f735b"></a><!-- doxytag: member="vocList.c::vll_destroy" ref="b10af1f0b19cb9493368bffe4a1f735b" args="(vocList_t *list, void(*func)(void *ptr))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vll_destroy           </td>
          <td>(</td>
          <td class="paramtype">vocList_t *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *ptr)&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy the List object and free resources. 
<p>
vll_destroy -- Destroy a List object and free all resources.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>Linked List object to be destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>Optional object delete function </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>No return value</dd></dl>
A pointer to a function to delete the "value" elements of nodes may optionally be specified, otherwise this operation only affects the list itself, and the external objects referenced in list elements are not affected. The signature for FUNC is the same as free(). 
</div>
</div><p>
<a class="anchor" name="f24b90be778084df7a1918c0b8b33d45"></a><!-- doxytag: member="vocList.c::vll_init" ref="f24b90be778084df7a1918c0b8b33d45" args="(long req_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list vll_init           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new linked ist. 
<p>
vll_init -- Create a new, empty linked list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Initial max size of list, or 0 for default </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Reference to List object</dd></dl>
A new, empty list is created. Initial storage for the index array used to randomly access the list may optionally be specified as SIZE. If SIZE=0, a default maximum size will be used. The maximum size of the list is a soft maximum, i.e., the list will be grown automatically as needed. 
</div>
</div><p>
<a class="anchor" name="26a1a38a174db6cd9d5903dad23cfcb8"></a><!-- doxytag: member="vocList.c::vll_next" ref="26a1a38a174db6cd9d5903dad23cfcb8" args="(vocList_t *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">obj vll_next           </td>
          <td>(</td>
          <td class="paramtype">vocList_t *&nbsp;</td>
          <td class="paramname"> <em>list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the next element in the list. 
<p>
vll_next -- Seek to the next position in the list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>Linked list to be accessed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the object stored at that node</dd></dl>
If the seek position is valid a pointer to the object at that location is returned, otherwise NULL. Attempting to seek beyond the end of the list results in NULL being returned. 
<p>References <a class="el" href="vocList_8c_source.html#l00125">vll_seek()</a>.</p>

</div>
</div><p>
<a class="anchor" name="94da8f1a5cf17ebf3c3e13aab340ddb6"></a><!-- doxytag: member="vocList.c::vll_prev" ref="94da8f1a5cf17ebf3c3e13aab340ddb6" args="(vocList_t *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">obj vll_prev           </td>
          <td>(</td>
          <td class="paramtype">vocList_t *&nbsp;</td>
          <td class="paramname"> <em>list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the previous element in the list. 
<p>
vll_prev -- Seek to the previous position in the list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>Linked list to be accessed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the object stored at that node</dd></dl>
If the seek position is valid a pointer to the object at that location is returned, otherwise NULL. Attempting to seek beyond the beginning of the list results in NULL being returned. 
<p>References <a class="el" href="vocList_8c_source.html#l00125">vll_seek()</a>.</p>

</div>
</div><p>
<a class="anchor" name="28e9778710835857c95b41cd83db5213"></a><!-- doxytag: member="vocList.c::vll_rebuild_index" ref="28e9778710835857c95b41cd83db5213" args="(vocList_t *list, int req_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vll_rebuild_index           </td>
          <td>(</td>
          <td class="paramtype">vocList_t *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>req_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rebuild the array index. 
<p>
vll_rebuild_index -- Internal routine to reallocate and rebuild the array index for the list if it overflows, or if elements are deleted other than at the end.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>Linked List object to be destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size for the new list, or zero if no change. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Execution status code</dd></dl>
EXIT_SUCCESS is returned if the new index is created successfully, otherwise EXIT_FAILURE. If an error occurs the old index is not replaced, but may no longer be valid (depending upon the calling routine). 
<p>Referenced by <a class="el" href="vocList_8c_source.html#l00380">vll_remove()</a>.</p>

</div>
</div><p>
<a class="anchor" name="72b0563b0c8c56ed8677410860b41b47"></a><!-- doxytag: member="vocList.c::vll_remove" ref="72b0563b0c8c56ed8677410860b41b47" args="(vocList_t *list, long req_pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vll_remove           </td>
          <td>(</td>
          <td class="paramtype">vocList_t *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>req_pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a node from the list. 
<p>
vll_remove -- Remove the node at the given position from the list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>Linked list to be accessed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position of item to be removed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the object stored in the node</dd></dl>
POS should be a valid node index from 0 to count-1, or the value -1 which causes the node at the current position to be removed (this allows a node to be removed without having to know its absolute position in the list). A pointer to the object referenced by the deleted node is returned upon successful completion, otherwise NULL is returned. POS is left pointing to the element preceding the deleted element. 
<p>References <a class="el" href="vocList_8c_source.html#l00479">vll_rebuild_index()</a>, and <a class="el" href="vocList_8c_source.html#l00125">vll_seek()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a9876d2307012b54e4b534e74e7593b9"></a><!-- doxytag: member="vocList.c::vll_seek" ref="a9876d2307012b54e4b534e74e7593b9" args="(vocList_t *list, long offset, int whence)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">obj vll_seek           </td>
          <td>(</td>
          <td class="paramtype">vocList_t *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>whence</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seek to the indicated position in the list. 
<p>
vll_seek -- Seek to the indicated position in the list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>Linked list to be accessed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset from the given position </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>whence</em>&nbsp;</td><td>Reference position for seek </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the object stored at that node</dd></dl>
The current position in the list is set to the node OFFSET positions from the reference point indicated by WHENCE: SEEK_SET (beginning of list), SEEK_CUR (current position), SEEK_END (end of list). The values of WHENCE are as defined in &lt;stdio.h&gt;. A seek to (0,SEEK_SET) positions to the beginning of the list, whereas (0,SEEK_END) positions ot the end of the list.<p>
If the seek position is valid a pointer to the object at that location is returned, otherwise NULL. A seek on an empty list always returns NULL since there is no object pointer to return. The current list position is unaffected if NULL is returned. 
<p>Referenced by <a class="el" href="vocList_8c_source.html#l00240">vll_next()</a>, <a class="el" href="vocList_8c_source.html#l00217">vll_prev()</a>, and <a class="el" href="vocList_8c_source.html#l00380">vll_remove()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Sep 23 09:21:35 2014 for DAL Client Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
